## Interfaces
- müssen bestimmte Methoden implementiert bekommen
- Klasse muss, wenn interface genutzt wird "extends Interface" im Methodenkopf haben, um sich den Inhalt des Interfaces zu bekommen
- Alle Methoden die in einem Interface sind müssen von der nutzenden Methode implementiert werden
- statt "class" ist das Keyword "interface"
	- "abstract" als Keyword - ist keine Pflicht
- @Overwrite nutzen um zu schauen, ob Implementation richtig ist - hier auch keine Pflicht
- Funktionen in Interfaces sind fast immer Abstrakt

## Lambda Ausdrücke
- Implementierung von funktionalen Klassen, die Schnittstellen implementieren
	- Schnittstellen mit genau einer abstrakten Methode
- Mini Funktionen die schnell und ohne großen Aufwand geschrieben werden kann
	- Kurz etwas ausrechnen/umformen, braucht aber keine ganze Funktion dafür
- Aufbau: x => x +2
- Keyword: Lambda
- Inferenz -> Folgern eines bestimmten Typs für einen gegebenen Ausdruck, obwohl der Typ nicht explizit angegeben wurde -> Rückschließung auf den richtigen Typen
- Zur Erstellung eines Lambda Ausdrucks muss zuerst ein Interface für diese Funktion erstellt werden
```java
//allgemeine Bennenung der Bezeichner
DoubleIntToDoubleFunktion mess4 = (gewicht, basisWert) -> basisWert * gewicht / 100;
ergDbl = mess4.anwenden(12.5, 200)
```
- Eine Funktion kann man auch generisch machen - für jeden Parameter einen generischen Datentypen:
```java
static public interface BiFunktion<I,U,R>{
	public R anwenden(T x1, U x2);
}

//Verwendung generischer Datentypen
BiFunktion<Double, Integer, Double> mess5 = (gewicht, basisWert) -> basiswert * gewicht / 100
ergDbl = mess5.anwenden(12.5, 200)
```
- Interfaces werden hier Funktionale Interfaces genannt

## Higher Order Function
- Funktionen, die andere Funktionen als Parameter bekommen

## Abschließen von Werten in Funktionen
- Funktionsabschlüsse
- Closures